# Filename: mod_harvester.py
import time
import os
import sys
import argparse
import logging
import platform
import zipfile
import json
from pathlib import Path

# Third-party dependencies
try:
    import geckodriver_autoinstaller
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.firefox.options import Options as FirefoxOptions
except ImportError:
    print("Error: Required libraries not found.")
    print("Please run: pip install selenium geckodriver-autoinstaller")
    sys.exit(1)

# GUI Dependencies
try:
    import tkinter as tk
    from tkinter import filedialog, messagebox, ttk
    HAS_GUI = True
except ImportError:
    HAS_GUI = False

# --- CONFIGURATION & PRESETS ---

# Verified Presets (Generated by preset_scraper.py)
# Most of these have moved to the main catalogue domain.
GAME_PRESETS = {
    "Custom (Advanced)": {"app_id": "", "base_url": ""},
    "Cities: Skylines": {"app_id": "255710", "base_url": "https://smods.ru/archives/{mod_id}"},
    "Hearts of Iron IV": {"app_id": "394360", "base_url": "https://hearts-of-iron-4.smods.ru/archives/{mod_id}"},
    "Stellaris": {"app_id": "281990", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "RimWorld": {"app_id": "294100", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Crusader Kings III": {"app_id": "1158310", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Europa Universalis IV": {"app_id": "236850", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Darkest Dungeon": {"app_id": "262060", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Barotrauma": {"app_id": "602960", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Teardown": {"app_id": "1167630", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Total War: WARHAMMER III": {"app_id": "1142710", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Garry's Mod": {"app_id": "4000", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "XCOM 2": {"app_id": "268500", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Sid Meier's Civilization VI": {"app_id": "289070", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Terraria": {"app_id": "105600", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Project Zomboid": {"app_id": "108600", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"},
    "Darkest Dungeon II": {"app_id": "1940340", "base_url": "https://catalogue.smods.ru/archives/{mod_id}"}
}

# Load external presets if available
external_presets_path = Path("verified_presets.json")
if external_presets_path.exists():
    try:
        with open(external_presets_path, 'r') as f:
            external_presets = json.load(f)
            # Merge, preferring external
            for name, data in external_presets.items():
                # Normalize keys
                clean_name = name.replace(" Mods", "")
                GAME_PRESETS[clean_name] = data
    except Exception as e:
        print(f"Warning: Could not load verified_presets.json: {e}")

class ModHarvester:
    def __init__(self, base_url, app_id, download_folder, mod_file, profile_path=None, headless=True, unzip=False):
        self.base_url = base_url
        self.app_id = app_id
        self.download_folder = Path(download_folder).resolve()
        self.mod_file = Path(mod_file).resolve()
        self.profile_path = profile_path
        self.headless = headless
        self.unzip = unzip
        self.driver = None
        self.wait = None
        self.start_time = time.time()
        
        self.setup_logging()

    def setup_logging(self):
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

    def setup_driver(self):
        logging.info("Setting up Firefox WebDriver...")
        geckodriver_autoinstaller.install()
        
        options = FirefoxOptions()
        if self.headless:
            options.add_argument("--headless")
        
        if self.profile_path:
            logging.info(f"Using Firefox profile: {self.profile_path}")
            options.add_argument("-profile")
            options.add_argument(self.profile_path)
        else:
            logging.warning("No Firefox profile provided. Ad-blocking will be disabled.")

        # Force Firefox to save where we want, no questions asked.
        options.set_preference("browser.download.folderList", 2)
        options.set_preference("browser.download.dir", str(self.download_folder))
        options.set_preference("browser.download.useDownloadDir", True)
        options.set_preference("browser.helperApps.neverAsk.saveToDisk", "application/zip, application/octet-stream")
        
        self.driver = webdriver.Firefox(options=options)
        self.wait = WebDriverWait(self.driver, 20)

    def read_mod_ids(self):
        if not self.mod_file.exists():
            logging.error(f"Mod ID file '{self.mod_file}' not found.")
            return []
        
        with open(self.mod_file, 'r') as f:
            return [line.strip() for line in f if line.strip()]

    def download_mod(self, mod_id, main_window_handle):
        try:
            logging.info(f"--- Processing Mod ID: {mod_id} ---")
            self.driver.switch_to.window(main_window_handle)
            
            # Build the URL
            try:
                target_url = self.base_url.format(mod_id=mod_id, app_id=self.app_id)
            except Exception:
                # Fallback if format fails
                target_url = self.base_url.replace("{mod_id}", mod_id).replace("{app_id}", self.app_id)
                
            logging.info(f"Navigating to: {target_url}")
            self.driver.get(target_url)

            # Find the download button. It varies by game.
            try:
                # CK3 style
                download_link_element = self.wait.until(EC.element_to_be_clickable((By.CLASS_NAME, "skymods-excerpt-btn")))
            except Exception:
                # Generic fallback
                download_link_element = self.wait.until(EC.element_to_be_clickable((By.PARTIAL_LINK_TEXT, "Download")))

            logging.info("Found initial download link. Clicking...")
            download_link_element.click()
            time.sleep(3)

            # Deal with popups
            for handle in self.driver.window_handles:
                if handle != main_window_handle:
                    self.driver.switch_to.window(handle)
                    if "modsbase.com" in self.driver.current_url:
                        logging.info(f"Switched to Modsbase tab: {self.driver.current_url}")
                        break 
            
            # Kill the cookie banner if it exists
            try:
                cookie_button = WebDriverWait(self.driver, 5).until(EC.element_to_be_clickable((By.XPATH, "//*[contains(text(), 'Accept')]")))
                cookie_button.click()
                time.sleep(1) 
            except Exception:
                pass

            # Wait for that annoying timer
            logging.info("Waiting for timer on Modsbase...")
            create_link_button = self.wait.until(EC.element_to_be_clickable((By.ID, "downloadbtn")))
            time.sleep(6) 
            self.driver.execute_script("arguments[0].click();", create_link_button) 
            logging.info("Clicked 'Create download link'.")

            final_download_link = self.wait.until(EC.element_to_be_clickable((By.PARTIAL_LINK_TEXT, ".zip")))
            logging.info("Found final download button. Initiating download...")
            self.driver.execute_script("arguments[0].click();", final_download_link) 
            
            logging.info(f"SUCCESS: Download initiated for Mod ID: {mod_id}.")
            time.sleep(5)

        except Exception as e:
            logging.error(f"ERROR processing {mod_id}: {e}")
        
        finally:
            # Cleanup tabs
            while len(self.driver.window_handles) > 1:
                self.driver.switch_to.window(self.driver.window_handles[-1])
                self.driver.close()
            self.driver.switch_to.window(main_window_handle)

    def process_unzip(self):
        logging.info("Scanning for new zip files to extract...")
        # Wait a bit for final downloads to finish writing
        time.sleep(5) 
        
        count = 0
        for file_path in self.download_folder.glob("*.zip"):
            # Check if file was modified/created after we started
            if file_path.stat().st_mtime > self.start_time:
                try:
                    logging.info(f"Extracting: {file_path.name}")
                    with zipfile.ZipFile(file_path, 'r') as zip_ref:
                        zip_ref.extractall(self.download_folder)
                    logging.info(f"Extracted {file_path.name}")
                    count += 1
                except zipfile.BadZipFile:
                    logging.error(f"Failed to extract {file_path.name}: Bad Zip File")
                except Exception as e:
                    logging.error(f"Failed to extract {file_path.name}: {e}")
        
        if count == 0:
            logging.info("No new zip files found to extract.")
        else:
            logging.info(f"Successfully extracted {count} archives.")

    def run(self):
        if not self.download_folder.exists():
            self.download_folder.mkdir(parents=True, exist_ok=True)
            
        mod_ids = self.read_mod_ids()
        if not mod_ids:
            logging.error("No mod IDs found to download.")
            return

        logging.info(f"Found {len(mod_ids)} mods to download.")
        self.setup_driver()
        
        try:
            if not self.base_url:
                logging.error("No Base URL provided.")
                return

            main_window_handle = self.driver.current_window_handle
            for mod_id in mod_ids:
                self.download_mod(mod_id, main_window_handle)
                
            logging.info(f"--- All downloads initiated. Check '{self.download_folder}' ---")
            
            if self.unzip:
                logging.info("Waiting 15 seconds for pending downloads to complete before unzipping...")
                time.sleep(15)
                self.process_unzip()
            
        finally:
            if self.driver:
                self.driver.quit()

# --- GUI IMPLEMENTATION ---

class HarvesterGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Steam Mod Downloader")
        self.root.geometry("550x550")
        
        # Game Selection
        tk.Label(root, text="Select Game (Verified Presets):").pack(pady=5)
        self.game_var = tk.StringVar()
        # Sort keys for easier finding
        sorted_games = sorted(list(GAME_PRESETS.keys()))
        self.game_combo = ttk.Combobox(root, textvariable=self.game_var, values=sorted_games)
        self.game_combo.pack(pady=5)
        self.game_combo.set("Cities: Skylines") # Default
        self.game_combo.bind("<<ComboboxSelected>>", self.toggle_custom_fields)

        # Custom Fields Frame
        self.custom_frame = tk.Frame(root)
        tk.Label(self.custom_frame, text="App ID:").grid(row=0, column=0, padx=5)
        self.app_id_entry = tk.Entry(self.custom_frame)
        self.app_id_entry.grid(row=0, column=1, padx=5)
        
        tk.Label(self.custom_frame, text="Base URL ({mod_id}, {app_id}):").grid(row=1, column=0, padx=5)
        self.base_url_entry = tk.Entry(self.custom_frame, width=30)
        self.base_url_entry.grid(row=1, column=1, padx=5)
        # self.custom_frame.pack(pady=5) # Hidden by default

        # File Selection
        tk.Label(root, text="Mod List File (txt):").pack(pady=5)
        self.file_frame = tk.Frame(root)
        self.file_frame.pack()
        self.file_entry = tk.Entry(self.file_frame, width=40)
        self.file_entry.insert(0, str(Path.cwd() / "mod_ids.txt"))
        self.file_entry.pack(side=tk.LEFT, padx=5)
        tk.Button(self.file_frame, text="Browse", command=self.browse_file).pack(side=tk.LEFT)

        # Output Folder
        tk.Label(root, text="Download Folder:").pack(pady=5)
        self.out_frame = tk.Frame(root)
        self.out_frame.pack()
        self.out_entry = tk.Entry(self.out_frame, width=40)
        self.out_entry.insert(0, str(Path.cwd() / "Mod_Downloads"))
        self.out_entry.pack(side=tk.LEFT, padx=5)
        tk.Button(self.out_frame, text="Browse", command=self.browse_folder).pack(side=tk.LEFT)

        # Options
        self.headless_var = tk.BooleanVar(value=True)
        tk.Checkbutton(root, text="Headless Mode (Hide Browser)", variable=self.headless_var).pack(pady=5)

        self.unzip_var = tk.BooleanVar(value=False)
        tk.Checkbutton(root, text="Auto-Unzip Downloaded Files", variable=self.unzip_var).pack(pady=5)

        # Start Button
        tk.Button(root, text="START DOWNLOAD", command=self.start_download, bg="#4CAF50", fg="white", font=("Arial", 12, "bold")).pack(pady=20)

        self.status_label = tk.Label(root, text="Ready", fg="gray")
        self.status_label.pack(side=tk.BOTTOM, pady=5)

    def toggle_custom_fields(self, event=None):
        if self.game_var.get() == "Custom (Advanced)":
            self.custom_frame.pack(pady=5)
        else:
            self.custom_frame.pack_forget()

    def browse_file(self):
        filename = filedialog.askopenfilename(filetypes=[("Text Files", "*.txt")])
        if filename:
            self.file_entry.delete(0, tk.END)
            self.file_entry.insert(0, filename)

    def browse_folder(self):
        foldername = filedialog.askdirectory()
        if foldername:
            self.out_entry.delete(0, tk.END)
            self.out_entry.insert(0, foldername)

    def start_download(self):
        game = self.game_var.get()
        mod_file = self.file_entry.get()
        download_folder = self.out_entry.get()
        headless = self.headless_var.get()
        unzip = self.unzip_var.get()

        if game == "Custom (Advanced)":
            app_id = self.app_id_entry.get()
            base_url = self.base_url_entry.get()
            if not base_url:
                messagebox.showerror("Error", "Please enter a Base URL for custom game.")
                return
        else:
            preset = GAME_PRESETS.get(game)
            app_id = preset["app_id"]
            base_url = preset["base_url"]

        if not os.path.exists(mod_file):
            messagebox.showerror("Error", "Mod list file not found!")
            return

        self.status_label.config(text="Running... Check console for details.")
        self.root.update()

        # Run Harvester
        try:
            harvester = ModHarvester(base_url, app_id, download_folder, mod_file, headless=headless, unzip=unzip)
            harvester.run()
            messagebox.showinfo("Success", "Download process completed!")
            self.status_label.config(text="Completed.")
        except Exception as e:
            messagebox.showerror("Error", str(e))
            self.status_label.config(text="Error occurred.")

# --- MAIN ENTRY POINT ---

def main():
    parser = argparse.ArgumentParser(description="Universal Steam Workshop Mod Downloader")
    parser.add_argument('-u', '--base_url', type=str, help="Base URL template (required if not using GUI/Preset)")
    parser.add_argument('-a', '--app_id', type=str, help="Steam App ID")
    parser.add_argument('-p', '--profile', type=str, help="Firefox profile path")
    parser.add_argument('-f', '--file', type=str, default="mod_ids.txt", help="Mod list file")
    parser.add_argument('-o', '--output', type=str, default="Mod_Downloads", help="Output directory")
    parser.add_argument('--headless', action='store_true', help="Run in headless mode")
    parser.add_argument('--gui', action='store_true', help="Force GUI mode")
    parser.add_argument('--cli', action='store_true', help="Force Interactive CLI mode (disable GUI)")
    parser.add_argument('--unzip', action='store_true', help="Auto-unzip downloaded files")
    
    args = parser.parse_args()

    # Determine mode
    # Priority: 
    # 1. CLI Args (base_url + app_id) -> Run immediately
    # 2. --cli flag -> Run Interactive CLI
    # 3. --gui flag -> Run GUI
    # 4. Default -> Run GUI if available, else Interactive CLI

    if args.base_url and args.app_id:
        # Direct CLI Mode
        harvester = ModHarvester(args.base_url, args.app_id, args.output, args.file, args.profile, args.headless, args.unzip)
        harvester.run()
    elif args.cli:
        # Forced Interactive CLI
        run_interactive_cli(args)
    elif args.gui and HAS_GUI:
        # Forced GUI
        root = tk.Tk()
        app = HarvesterGUI(root)
        root.mainloop()
    elif HAS_GUI:
        # Default to GUI if available
        root = tk.Tk()
        app = HarvesterGUI(root)
        root.mainloop()
    else:
        # Fallback to Interactive CLI
        run_interactive_cli(args)

def run_interactive_cli(args):
    print("--- Interactive Mode ---")
    print("Available Games:")
    games = sorted(list(GAME_PRESETS.keys()))
    for i, game in enumerate(games):
        print(f"{i+1}. {game}")
    
    try:
        choice = int(input("Select Game (Number): ")) - 1
        selected_game = games[choice]
    except (ValueError, IndexError):
        print("Invalid selection.")
        return

    base_url = None
    app_id = None

    if selected_game == "Custom (Advanced)":
        app_id = input("Enter App ID: ")
        base_url = input("Enter Base URL template: ")
    else:
        preset = GAME_PRESETS[selected_game]
        app_id = preset["app_id"]
        base_url = preset["base_url"]

    mod_file = input(f"Mod list file [{args.file}]: ") or args.file
    output = input(f"Output folder [{args.output}]: ") or args.output
    
    unzip_input = input(f"Auto-unzip files? (y/N): ").lower()
    unzip = unzip_input == 'y' or args.unzip
    
    harvester = ModHarvester(base_url, app_id, output, mod_file, unzip=unzip)
    harvester.run()

if __name__ == "__main__":
    main()